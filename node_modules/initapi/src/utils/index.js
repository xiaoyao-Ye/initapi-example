"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Desc = exports.getFuncNameByOpenApi = exports.getFuncName = exports.toLowerCaseFirst = exports.clearCRLF = exports.isHttp = exports.readJson = exports.tryRequire = void 0;
const path_1 = require("path");
const fs_1 = __importDefault(require("fs"));
const jiti_1 = __importDefault(require("jiti"));
function tryRequire(id, rootDir = process.cwd()) {
    const _require = (0, jiti_1.default)(rootDir, { interopDefault: true });
    try {
        return _require(id);
    }
    catch (err) {
        if (err.code !== "MODULE_NOT_FOUND") {
            console.error(`Error trying import ${id} from ${rootDir}`, err);
        }
        return {};
    }
}
exports.tryRequire = tryRequire;
/**
 * 读取json文件
 * @param url 文件路径
 * @returns JSON.parse后的数据
 */
const readJson = (url) => {
    // 转义并将路径处理成正确的当前系统(window和mac的路径差异)路径
    let URL = (0, path_1.join)(String.raw `${url}`);
    // 处理成绝对路径
    if (!(0, path_1.isAbsolute)(URL))
        URL = (0, path_1.join)(__dirname, URL);
    try {
        return JSON.parse(fs_1.default.readFileSync(URL, "utf-8"));
    }
    catch (error) {
        throw new Error("读取json文件错误!");
    }
};
exports.readJson = readJson;
/** 是否网址 */
const isHttp = (url) => {
    // return /^(((ht|f)tps?):\/\/)?([^!@#$%^&*?.\s-]([^!@#$%^&*?.\s]{0,63}[^!@#$%^&*?.\s])?\.)+[a-z]{2,6}\/?/.test(url)
    return /(http|https):\/\/([\w.]+\/?)\S*/.test(url);
};
exports.isHttp = isHttp;
/** 清除\r\n */
const clearCRLF = (desc) => (desc !== null && desc !== void 0 ? desc : "").replace(/\r\n/g, "");
exports.clearCRLF = clearCRLF;
/**
 * 字符串首字母转换为小写
 * @param funcName 函数名称
 * @returns 函数名称首字母小写
 */
function toLowerCaseFirst(funcName = "") {
    return funcName.charAt(0).toLowerCase() + funcName.slice(1);
}
exports.toLowerCaseFirst = toLowerCaseFirst;
/**
 * 根据url获取函数名称 去除url中的 {} 内容
 * @param url api地址
 * @param className api的class name
 * @returns 函数名称
 */
function getFuncName(url, className) {
    const reg = /\/{[\w]*\}/g;
    const urlStr = url.replace(reg, "");
    const urlArr = urlStr.split("/");
    // 目前的方案是去掉url的{}后截取className往后的所有str组成函数名称(目前好像效果好很多), 如果一个都没有,取最后一个
    // 之前的方案是去掉url的{}后通过/分割, 使用数组最后一个str作为函数名称
    const index = urlArr.findIndex((f) => f === className);
    const name = urlArr
        .splice(index + 1)
        .map((m) => m.charAt(0).toUpperCase() + m.slice(1))
        .join("");
    return toLowerCaseFirst(name || urlArr[urlArr.length - 1]);
}
exports.getFuncName = getFuncName;
/**
 * 根据openApi规则生成函数名称
 * @param url api地址
 * @param className api的class name
 * @param method 请求方法
 * @returns 函数名称
 */
function getFuncNameByOpenApi(url, className, method) {
    // 移除url字符串中的花括号
    const reg = /\{|\}/g;
    const urlStr = url.replace(reg, "");
    const urlArr = urlStr.split("/");
    const index = urlArr.findIndex((f) => f === className);
    const name = urlArr.splice(index + 1).join("_");
    return `${method}_${name}`;
}
exports.getFuncNameByOpenApi = getFuncNameByOpenApi;
/**
 * 传入注释字符串 不为空则返回 \/** desc *\/ 格式
 * @param desc 备注
 */
const Desc = (desc) => {
    return desc ? `/** ${desc} */` : "";
};
exports.Desc = Desc;
